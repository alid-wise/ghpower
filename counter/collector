#!/usr/bin/perl -w
use strict;
$| = 1;

#
#       Copyright (C) 2008-2012 áÌÅËÓÁÎÄÒ äÅ×ÑÔËÉÎ, "úÅÌ£ÎÁÑ ÇÏÒËÁ"
#
#       òÁÚÒÅÛÁÅÔÓÑ ÐÏ×ÔÏÒÎÏÅ ÒÁÓÐÒÏÓÔÒÁÎÅÎÉÅ É ÉÓÐÏÌØÚÏ×ÁÎÉÅ ËÁË × ×ÉÄÅ ÉÓÈÏÄÎÏÇÏ
#       ËÏÄÁ, ÔÁË É × Ä×ÏÉÞÎÏÊ ÆÏÒÍÅ, Ó ÉÚÍÅÎÅÎÉÑÍÉ ÉÌÉ ÂÅÚ, ÐÒÉ ÓÏÂÌÀÄÅÎÉÉ ÓÌÅÄÕÀÝÉÈ
#       ÕÓÌÏ×ÉÊ:
#
#       * ðÒÉ ÐÏ×ÔÏÒÎÏÍ ÒÁÓÐÒÏÓÔÒÁÎÅÎÉÉ ÉÓÈÏÄÎÏÇÏ ËÏÄÁ ÄÏÌÖÎÏ ÏÓÔÁ×ÁÔØÓÑ ÕËÁÚÁÎÎÏÅ
#         ×ÙÛÅ Õ×ÅÄÏÍÌÅÎÉÅ ÏÂ Á×ÔÏÒÓËÏÍ ÐÒÁ×Å, ÜÔÏÔ ÓÐÉÓÏË ÕÓÌÏ×ÉÊ É ÐÏÓÌÅÄÕÀÝÉÊ
#         ÏÔËÁÚ ÏÔ ÇÁÒÁÎÔÉÊ.
#       * ðÒÉ ÐÏ×ÔÏÒÎÏÍ ÒÁÓÐÒÏÓÔÒÁÎÅÎÉÉ Ä×ÏÉÞÎÏÇÏ ËÏÄÁ ÄÏÌÖÎÁ ÓÏÈÒÁÎÑÔØÓÑ ÕËÁÚÁÎÎÁÑ
#         ×ÙÛÅ ÉÎÆÏÒÍÁÃÉÑ ÏÂ Á×ÔÏÒÓËÏÍ ÐÒÁ×Å, ÜÔÏÔ ÓÐÉÓÏË ÕÓÌÏ×ÉÊ É ÐÏÓÌÅÄÕÀÝÉÊ ÏÔËÁÚ
#         ÏÔ ÇÁÒÁÎÔÉÊ × ÄÏËÕÍÅÎÔÁÃÉÉ É/ÉÌÉ × ÄÒÕÇÉÈ ÍÁÔÅÒÉÁÌÁÈ, ÐÏÓÔÁ×ÌÑÅÍÙÈ ÐÒÉ
#         ÒÁÓÐÒÏÓÔÒÁÎÅÎÉÉ.
#       * îÉ ÎÁÚ×ÁÎÉÅ "úÅÌ£ÎÁÑ ÇÏÒËÁ", ÎÉ ÉÍÅÎÁ ÅÅ ÓÏÔÒÕÄÎÉËÏ× ÎÅ ÍÏÇÕÔ ÂÙÔØ
#         ÉÓÐÏÌØÚÏ×ÁÎÙ × ËÁÞÅÓÔ×Å ÐÏÄÄÅÒÖËÉ ÉÌÉ ÐÒÏÄ×ÉÖÅÎÉÑ ÐÒÏÄÕËÔÏ×, ÏÓÎÏ×ÁÎÎÙÈ
#         ÎÁ ÜÔÏÍ ðï ÂÅÚ ÐÒÅÄ×ÁÒÉÔÅÌØÎÏÇÏ ÐÉÓØÍÅÎÎÏÇÏ ÒÁÚÒÅÛÅÎÉÑ.
#
#       üôá ðòïçòáííá ðòåäïóôá÷ìåîá ÷ìáäåìøãáíé á÷ôïòóëéè ðòá÷ é/éìé äòõçéíé óôïòïîáíé
#	"ëáë ïîá åóôø" âåú ëáëïçï-ìéâï ÷éäá çáòáîôéê, ÷ùòáöåîîùè ñ÷îï éìé ðïäòáúõíå÷áåíùè,
#	÷ëìàþáñ, îï îå ïçòáîéþé÷áñóø éíé, ðïäòáúõíå÷áåíùå çáòáîôéé ëïííåòþåóëïê ãåîîïóôé
#	é ðòéçïäîïóôé äìñ ëïîëòåôîïê ãåìé. îé ÷ ëïåí óìõþáå, åóìé îå ôòåâõåôóñ
#	óïïô÷åôóô÷õàýéí úáëïîïí, éìé îå õóôáîï÷ìåîï ÷ õóôîïê æïòíå, îé ïäéî ÷ìáäåìåã
#	á÷ôïòóëéè ðòá÷ é îé ïäîï äòõçïå ìéãï, ëïôïòïå íïöåô éúíåîñôø é/éìé ðï÷ôïòîï
#	òáóðòïóôòáîñôø ðòïçòáííõ, ëáë âùìï óëáúáîï ÷ùûå, îå îåó³ô ïô÷åôóô÷åîîïóôé,
#	÷ëìàþáñ ìàâùå ïâýéå, óìõþáêîùå, óðåãéáìøîùå éìé ðïóìåäï÷á÷ûéå õâùôëé,
#	÷óìåäóô÷éå éóðïìøúï÷áîéñ éìé îå÷ïúíïöîïóôé éóðïìøúï÷áîéñ ðòïçòáííù (÷ëìàþáñ,
#	îï îå ïçòáîéþé÷áñóø ðïôåòåê äáîîùè, éìé äáîîùíé, óôá÷ûéíé îåðòá÷éìøîùíé, éìé
#	ðïôåòñíé ðòéîåóåîîùíé éú-úá ÷áó éìé ôòåôøéè ìéã, éìé ïôëáúïí ðòïçòáííù òáâïôáôø
#	óï÷íåóôîï ó äòõçéíé ðòïçòáííáíé), äáöå åóìé ôáëïê ÷ìáäåìåã éìé äòõçïå ìéãï âùìé
#	éú÷åýåîù ï ÷ïúíïöîïóôé ôáëéè õâùôëï÷.
#

#       Copyright (C) 2008-2012 Aleksandr Deviatkin, "Green Hill"
#
#       Redistribution and use in source and binary forms, with or without
#       modification, are permitted provided that the following conditions are
#       met:
#       
#       * Redistributions of source code must retain the above copyright
#         notice, this list of conditions and the following disclaimer.
#       * Redistributions in binary form must reproduce the above
#         copyright notice, this list of conditions and the following disclaimer
#         in the documentation and/or other materials provided with the
#         distribution.
#       * Neither the name of the Green Hill nor the names of its
#         contributors may be used to endorse or promote products derived from
#         this software without specific prior written permission.
#       
#       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#       "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#       A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#       OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#       SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#       LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#       DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#       THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#       OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

#
# óÂÏÒ ÄÁÎÎÙÈ ÓÏ ÓÞÅÔÞÉËÏ× ÇÒÕÐÐÙ
# 2011-11-27 alid
#

use DBI;
use Carp;
use Time::Local;
use lib "$ENV{MY}/counter";
use Lock;


my (@args, %opts);
foreach(@ARGV){
   if(/^\-(\S)(.*)/){	$opts{$1} = $2;	} else {	push @args, $_;	}
}
my $verb = exists $opts{v};
my $retries = $opts{r} || 1;
my $force = exists $opts{f};	# ÉÇÎÏÒÉÒÏ×ÁÔØ ÏÔÓÕÔÓÔ×ÉÅ ÆÌÁÇÁ mgroup.active
my ($database,$mgid) = (@args);
die "Usage: $0 database mgroup_id"	unless($database);
$mgid ||= 1;
my $cget203 = "$ENV{MY}counter/mon203 -r$retries";
my $cget230 = "$ENV{MY}counter/mon230 -r$retries";

# çÌÏÂÁÌØÎÁÑ ÂÌÏËÉÒÏ×ËÁ ÐÒÏÃÅÓÓÏÍ ÐÏÉÓËÁ ÉÎÔÅÒÆÅÊÓÏ× port_locator
# 2014-05-14 alid
my $plock = '/tmp/port_locator.lock';
my $Plock = Lock->new($plock,1);
exit 1	if($Plock->get());
#

my $lock = Lock->new("/tmp/counter.collector.$mgid.lock",1);
die "collector: Locked for mgroup $mgid"	if($lock->set);

my $dbh = DBI->connect("dbi:Pg:dbname=$database","","",{AutoCommit => 1})	or die;

# ÓÐÉÓÏË ÓÞÅÔÞÉËÏ×
my $sth = $dbh->prepare("select counters.id,counters.name,counters.addr,counters.passwd,iface.dev,counters.ktrans,counter_type.type,status.id as status_id,status.state,status.pstate from counters inner join mgroup on mgroup.id=counters.mgroup inner join iface on mgroup.if_id=iface.id inner join counter_type on model=counter_type.id left outer join status on counters.id=status.cid where counters.active=1 and counters.mgroup=? ".($force? "":"and mgroup.active=1")." order by counters.id");
$sth->execute($mgid)	or die;
my $List;
while(my $row = $sth->fetchrow_hashref) {
	push @$List, $row;
}
$sth->finish;

my $sins = $dbh->prepare("insert into status (cid,state,pstate,se1,se2,lpower,modtime) values (?,?,?,?,?,?,now())");
my $supd = $dbh->prepare("update status set state=?,pstate=?,se1=?,se2=?,lpower=?,modtime=now() where id=?");
my $ins1 = $dbh->prepare("insert into monitor (dt,date,counter,mv1,mc1,mf,mps,mss,se1ai,se2ai) values (?,?,?,?,?,?,?,?,?,?) returning ise");
my $ins2 = $dbh->prepare("insert into monitor (dt,date,counter,mv1,mv2,mv3,mc1,mc2,mc3,mf,ma1,ma2,ma3,mps,mp1,mp2,mp3,mqs,mq1,mq2,mq3,mss,ms1,ms2,ms3,mks,mk1,mk2,mk3,se1ai,se1ae,se1ri,se1re,se2ai,se2ae,se2ri,se2re) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) returning ise");


# ×ÏÔ ÔÕÔ
foreach my $counter (@$List) {
	print "get: ".$counter->{addr}	if $verb;
	my $err = 0;
	my $Data;
	my ($addr,$mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re);
	map {$_=0;} ($addr,$mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re);
	my $time = time();
	my $tm = Now();
	my $lpower = 0;
	if($counter->{type} =~ /M203/) {
		print " M203\n"	if $verb;
		eval{ $Data = `$cget203 $counter->{addr} $counter->{dev}`; };
		chomp $Data;
		$Data =~ s/,/\./g;
		($addr, $mv1,$mc1,$mf,$mps,$mss,$se1ai,$se2ai) = split(";",$Data);
		if($addr && $addr eq $counter->{addr}) {
			map { $_ = ($_=~/null/i) ? 0 : $_; } ($mv1,$mc1,$mf,$mps,$mss,$se1ai,$se2ai);
			$ins1->execute($tm,$time,$counter->{id},$mv1,$mc1,$mf,$mps,$mss,$se1ai,$se2ai)	or die;
			$lpower = $ins1->fetch()->[0];
			$ins1->finish;
#			$dbh->do("insert into monitor (dt,date,counter,mv1,mc1,mf,mps,mss,se1ai,se2ai) values ('$tm',$time,$counter->{id},$mv1,$mc1,$mf,$mps,$mss,$se1ai,$se2ai)")	or die;
		} else {
			$err++;
			print "Error reading from: ".$counter->{addr}." (1f)\n"	if($verb);
		}
	}
	elsif($counter->{type} =~ /M230/) {
		print " M230\n"	if $verb;
		eval{ $Data = `$cget230 $counter->{addr} $counter->{passwd} $counter->{dev} $counter->{ktrans}`; };
		chomp $Data;
		$Data =~ s/,/\./g;
		($addr,$mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re) = split(";",$Data);
		if($addr && $addr eq $counter->{addr}) {
			map { $_ = ($_=~/null/i) ? 0 : $_; } ($mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re);
			$ins2->execute($tm,$time,$counter->{id},$mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re)	or die;
			$lpower = $ins2->fetch()->[0];
			$ins2->finish;
#		$dbh->do("insert into monitor (dt,date,counter,mv1,mv2,mv3,mc1,mc2,mc3,mf,ma1,ma2,ma3,mps,mp1,mp2,mp3,mqs,mq1,mq2,mq3,mss,ms1,ms2,ms3,mks,mk1,mk2,mk3,se1ai,se1ae,se1ri,se1re,se2ai,se2ae,se2ri,se2re) values ('$tm',$time,$counter->{id},$mv1,$mv2,$mv3,$mc1,$mc2,$mc3,$mf,$ma1,$ma2,$ma3,$mps,$mp1,$mp2,$mp3,$mqs,$mq1,$mq2,$mq3,$mss,$ms1,$ms2,$ms3,$mks,$mk1,$mk2,$mk3,$se1ai,$se1ae,$se1ri,$se1re,$se2ai,$se2ae,$se2ri,$se2re)")	or die;
		} else {
			$err++;
			print "Error reading from: ".$counter->{addr}." (3f)\n"	if($verb);
		}
	} else {
		print " ERROR: unknown device type [".$counter->{type}."]\n"	if $verb;
		next;
	}
	# úÁÐÉÓØ ÓÏÓÔÏÑÎÉÑ ÓÞÅÔÞÉËÁ
	$counter->{pstate} = $counter->{state} || 0;
	$counter->{state} = $err;
	if($counter->{"status_id"}) {
		$supd->execute($counter->{state},$counter->{pstate},$se1ai,$se2ai,$lpower,$counter->{"status_id"});
	} else {
		$sins->execute($counter->{id},$counter->{state},$counter->{pstate},$se1ai,$se2ai,$lpower);
	}
	print "done: ".$counter->{addr}."\n"	if $verb;
}

$dbh->disconnect;
$lock->clear;

sub Now {
        my ($stamp, %opts) = @_;
        $stamp = time()         unless defined $stamp;
        my ($sec, $min, $hour, $mday, $mon, $year) = localtime( $stamp );
        return $opts{iso} ?
                sprintf("%.4d-%.2d-%.2d %.2d:%.2d:%.2d", $year+1900, $mon+1, $mday, $hour, $min, $sec) :
                sprintf("%.2d.%.2d.%.4d %.2d:%.2d:%.2d", $mday, $mon+1, $year+1900, $hour, $min, $sec) ;
}

